#!/usr/bin/perl

# quadtool
# John Jacobsen, NPX Designs, Inc., jacobsen@npxdesigns.com
# Started: Fri Jul  1 13:40:54 2005

package QUADTOOL;

sub usage { return <<EOU;
Usage: quadtool <card> 01 or <card> 23
          01: first quad (wire pairs 0, 1)
	  23: second quad (wire pairs 2, 3)
Options:
	  -t : Log results to terminal; don't background
          -s (x%) : Scale duration by x%.  Default: 100% (~15min)

EOU
;
}


use Fcntl;
use strict;


use Getopt::Long;
my $interactive;
my $help;
my $scale = 100;
GetOptions("help|h"          => \$help,
           "scale|s=i"       => \$scale,
	   "t"               => \$interactive) || die usage;
die usage if $help;

my $scalefactor = $scale/100;
sub minscale { my $v = (shift)*($scalefactor); return 1 if $v < 1; return $v; }
my $numOpenTests             = minscale(100);
my $numConfigBootPromptTests = minscale(100);
my $numIceBootSoftBootTests  = minscale(20);
my $numEchoMessagesPerFW     = minscale(3000);
my $maxICCIs                 = 50;
my $maxRETX                  = 100;
my $maxBADSEQ                = 100;

sub checkForRunning;
sub driverPresent;
sub driverVersion;
sub moatVersion { my $mv = `cat /usr/local/share/moat-version`; chomp $mv; return $mv; }
sub hostName { my $h = `hostname 2>&1`; chomp $h; return $h; }
sub plugged;
sub timeString;
sub pairCurrent;
sub pairVoltage;
sub currentIsSmall { my $cur = shift; return $cur < 5 ? 1 : 0; }
sub pairIsPowered;
sub resetPowerLimitChecks;
sub onCurrentVoltageWithinLimits;
sub hadHardwareTimeout;
sub resetComstats;
sub doDom;
sub powerDownPair;
sub is_communicating;
sub powerOnPair;
sub getPostRunStatus;
sub reapKids;
sub comstat;
sub fpga;
sub nTXIC; sub nRXIC; sub nTXCI; sub nRXCI;
sub showDomFailures;
sub haveDOR { my $c=shift; return 0 unless -d "/proc/driver/domhub/card$c"; return 1; }

print "Welcome to $0, by jacobsen\@npxdesigns.com.\n";
# checkForRunning; <-- SKIP this - we already check for power-on.

my $card = shift; 
die usage unless defined $card && $card =~ /^\d+$/ && $card >= 0 && $card <= 7;

my $pairPair = shift;
die usage unless $pairPair eq "01" || $pairPair eq "23";
my @pairs;
if($pairPair eq "01") { @pairs = (0, 1); }
if($pairPair eq "23") { @pairs = (2, 3); }

if(!haveDOR($card)) {
    die "There is no DOR card $card on this domhub!\n";
}

my $now = timeString;
my $testdir = "QUADTOOL__card$card"."_pair$pairPair"."_$now";
my $logfile = "QUADTOOL.out";

print "Creating $testdir... ";
mkdir $testdir or die "Can't create $testdir: $!\n";
print "OK.\n";
print "Creating symlink latest_quadtool to $testdir... ";
if(-e "latest_quadtool") {
    unlink "latest_quadtool" or die "Can't unlink existing latest_quadtool: $!\n";
}
unlink "latest_quadtool";
symlink($testdir, "latest_quadtool")
    or die "Can't symlink $testdir"."->latest_quadtool: $!.\n";
print "OK.\n";

chdir $testdir || die "Can't chdir $testdir: $!\n";

exit if ! $interactive && fork;

open LOG, ">$logfile" || die "Can't open $logfile: $!\n";
my $ofh = select(LOG); $| = 1; select $ofh;

sub logmsg { my $m = shift; print LOG $m; if($interactive) { print $m; } }
sub logdie { my $m = shift; print LOG $m; if($interactive) { die $m; } else { exit(-1); } }

logdie "No DOR driver present!\n" unless driverPresent;
logmsg "\n---------------------------------------------------\nCONFIGURATION:\n";
logmsg "   Test start time: $now\n";
logmsg "DOR driver version: ".driverVersion."\n";
logmsg "      MOAT version: ".moatVersion."\n";
logmsg "          Hostname: ".hostName."\n";
logmsg "          DOR card: $card\n";
logmsg "        Wire pairs: ".(join ' ', @pairs)."\n";
my %pairstat;
my %domstat;

foreach my $pair (@pairs) {
    $pairstat{$pair} = "GOOD";
    foreach my $dom ("A","B") {
        $domstat{$pair}{$dom} = "GOOD";
    }
}

sub failPair { 
    my $pair = shift; logdie unless defined $pair;
    $pairstat{$pair} = "BAD"; 
    $domstat{$pair}{"A"} = "BAD";
    $domstat{$pair}{"B"} = "BAD";
}

sub failDom {
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    $domstat{$pair}{$dom} = "BAD";
}

sub iffyDom {
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    $domstat{$pair}{$dom} = "POOR";
}

logmsg "\n---------------------------------------------------\nTEST DETAILS:\n";

foreach my $pair (@pairs) {
    $pairstat{$pair} = "GOOD";

    logmsg "Pair $pair... ";
    if(!plugged($card, $pair)) {
	logmsg "\nPair $pair is NOT plugged in.\n";
	failPair($pair);
	next;
    } else {
	logmsg "plugged in... ";
    }
    if(pairIsPowered($card, $pair)) {
	logmsg "\nPail $pair is already powered on!  "
	    .  "Please make sure nobody\n is using the "
	    .  "DOMs, and \"off all\" first....\n";
	exit;
    }
    my $current = pairCurrent($card,$pair);
    logmsg "off-current $current mA: ";
    if(!currentIsSmall($current)) {
	logmsg "\nCurrent with power off is too large!\n";
	failPair($pair);
	next;
    } else {
	logmsg "OK.\n";
    }

    resetComstats($card, $pair, "A");
    resetComstats($card, $pair, "B");
    resetPowerLimitChecks($card, $pair);
}

foreach my $pair (@pairs) {
    if($pairstat{$pair} ne "BAD") {
	logmsg "Pair $pair PWR ON... ";
	my %isCom = powerOnPair($card, $pair);
	my $voltage;
	my $current  = pairCurrent($card, $pair);
	if(dorRev($card) > 0) {
	    $voltage = pairVoltage($card, $pair)." V";
	} else {
	    $voltage = "(no voltage avail. for Rev 0)";
	}
	logmsg "$current mA, $voltage... ";
	# Check current, voltage
	if(dorRev($card) > 0 && !onCurrentVoltageWithinLimits($card, $pair)) {
	    logmsg "\nCurrent or voltage is not in limits!\n"
		.  `cat /proc/driver/domhub/card$card/pair$pair/pwr_check`;
	    failPair($pair);
	    next;
	}
	foreach my $dom ("A", "B") {
	    if(! $isCom{$dom}) {
		logmsg "\nPair $pair DOM $dom is NOT communicating after power on.\n";
		failDom($pair,$dom);
		next;
	    } 
	    logmsg "$dom is-communicating; ";
	}
	# Next step - check again, look for hardware timeouts
	sleep 1;
	logmsg "\n";
	foreach my $dom ("A", "B") {
	    if($domstat{$pair}{$dom} ne "BAD") {
		logmsg "Recheck DOM $dom: ";
		if(! is_communicating($card, $pair, $dom)) {
		    logmsg "\nPair $pair DOM $dom did not communicate a short while "
			.  "after power on.\n";
		    logmsg "Comstat for $card$pair$dom:\n";
		    logmsg comstat($card,$pair,$dom);
		    logmsg sprintf("$card$pair$dom %s communicating.\n",
				   is_communicating($card,$pair,$dom)?"is":"is NOT");
		    
		    failDom($pair, $dom);
		    next;
		}
		logmsg "$dom is-communicating... ";
		if(hadHardwareTimeout($card, $pair, $dom)) {
		    logmsg "\nDOM $dom had a hardware timeout!\n";
		    logmsg "Comstat for $card$pair$dom:\n";
		    logmsg comstat($card,$pair,$dom);
		    logmsg sprintf("$card$pair$dom %s communicating.\n",
				   is_communicating($card,$pair,$dom)?"is":"is NOT");
		    
		    failDom($pair, $dom);
		    next;
		}
		logmsg "no hardware timeout.\n";
	    }
	}
    }
}

my $runParallelTests = 0;
foreach my $pair (@pairs) {
    if($pairstat{$pair} ne "BAD") {
        foreach my $dom ("A", "B") {
            if($domstat{$pair}{$dom} ne "BAD") {
		$runParallelTests = 1;
	    }
	}
    }
}

if($runParallelTests) {
    logmsg "Launching comms quality tests on good DOMs.\n"
	.  "See files in $testdir for detailed results for each DOM.\n";
    logmsg "Waiting for tests to complete...\n";

    foreach my $pair (@pairs) {
	# Perform parallel comms test for each DOM.
	if($pairstat{$pair} ne "BAD") {
	    foreach my $dom ("A", "B") { 
		if($domstat{$pair}{$dom} ne "BAD") {
		    my $domLog = "$pair$dom.log"; 
		    my $pid = fork;
		    if(!defined $pid) {
			logmsg "Fork failed on $pair $dom!  DOM Hub memory low??\n";
			next;
		    }
		    if($pid == 0) { # Kid does stuff
			doDom($card, $pair, $dom, $domLog);
			exit;
		    }
		} 		    
	    }
	}
    }
}

reapKids;

logmsg "Done.\n";
logmsg "\n---------------------------------------------------\n";

my @detailedDOMLogs;

logmsg "Final DOM status summary:\n";
foreach my $pair (@pairs) {
    logmsg "Card $card pair $pair: ";
    my $stat = $pairstat{$pair}; 
    if($stat eq "BAD") {
	logmsg "BAD\n"; 
    } else {
	logmsg "\n";
	foreach my $dom ("A","B") {
	    my $domStatus = getPostRunStatus("$pair$dom.log");
	    push(@detailedDOMLogs, "$pair$dom.log") unless $domStatus eq "GOOD";
	    logmsg "        DOM $dom: $domStatus\n";
	}
    }
    powerDownPair($card, $pair);
}

showDomFailures(@detailedDOMLogs);

logmsg "Done.\n";
close LOG;
exit;

sub doDom {
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    logdie unless ($dom eq "A" || $dom eq "B");
    my $log  = shift; logdie unless defined $log;
    open (DL, ">$log") or logdie "Can't open $log: $!\n";
    my $domStatus = $domstat{$pair}{$dom};
    print DL "Starting comms. tests on $card$pair$dom...\n" if $interactive;

    my $opensum    = 0;
    my $packetloss = 0;

    sub showstats {
	my $what    = shift;
	my $mxicci  = shift;
	my $nRXIC   = nRXIC($card,$pair,$dom);
	my $nRXCI   = nRXCI($card,$pair,$dom);
	my $nTXIC   = nTXIC($card,$pair,$dom);
	my $nTXCI   = nTXCI($card,$pair,$dom);
	$opensum   += $nRXIC + $nRXCI + $nTXIC + $nTXCI;
	my $nretx   = nRESENT($card, $pair, $dom);
	my $nbadseq = nBADSEQ($card, $pair, $dom);
	$packetloss += $nretx + $nbadseq;
	printf DL "$card$pair$dom %25s: "
	    .    "RX ICs=%02d RX CIs=%02d TX ICs=%02d "
	    .    "TX CIs=%02d RESENT=%02d BADSEQ=%02d\n", 
	         $what, $nRXIC, $nRXCI, $nTXIC, $nTXCI, $nretx, $nbadseq;
	
	if($nretx > $maxRETX || $nbadseq > $maxBADSEQ) {
	    print DL "\tHigh bad packet count!\n";
	    $domStatus = "POOR";
	}
	if($nRXIC > $mxicci || $nRXCI > $mxicci ||
	   $nTXIC > $mxicci || $nTXCI > $mxicci) {
	    print DL "\tHigh IC/CI count!\n";
	    $domStatus = "POOR";
	}
	if(hadHardwareTimeout($card,$pair,$dom)) {
	    print DL "\tHardware timeout!\n";
	    print DL comstat($card,$pair,$dom);
	    print DL fpga($card);
	    $domStatus = "BAD";
	} 
    } 

    # Perform multiple open tests
    logmsg "$card$pair$dom performing multiple open tests...\n";
    resetComstats($card, $pair, $dom);
    foreach my $trial (0..$numOpenTests-1) {
	my $domfile = "/dev/dhc$card"."w$pair"."d$dom";
	logdie "DOM /dev file $domfile not found!\n" unless -e $domfile;
	if(!sysopen(DOM, $domfile, O_RDWR)) {
	    print DL "Open $trial FAILED ($!)\n";
	    print DL comstat($card,$pair,$dom);
	    print DL fpga($card);
	    $domStatus = "BAD";
	    last;
	} 
	close DOM || logdie "Can't close $domfile: $!\n";
    }

    if($domStatus ne "BAD") {
	showstats("open test ($numOpenTests trials)", $maxICCIs*$numOpenTests);
    }

    resetComstats($card, $pair, $dom);
    # Run configboot tests and check for correct response
    if($domStatus ne "BAD") {
	logmsg "$card$pair$dom configboot prompt tests...\n" if $interactive;
	foreach my $trial (0..$numConfigBootPromptTests-1) {
	    # Perform configboot CR test
	    my $prompt = "#";
	    my $cmd = "se.pl $card$pair$dom \\  \\$prompt 2>&1";
	    my $result = `$cmd`;
	    if($result !~ /SUCCESS/) {
		print DL "\nCard $card pair $pair DOM $dom: Didn't get configboot prompt:\n"
		    .    "$result\n";
		print DL comstat($card,$pair,$dom);
		print DL fpga($card);
		$domStatus = "BAD";
		last;
	    }

	}
    }

    # Check RESENT and BADSEQ after configboot tests
    if($domStatus ne "BAD") {
	showstats("cbtests",$maxICCIs * $numConfigBootPromptTests);
    }

    my $domtag = "NOT AVAILABLE";
    # Put DOMs in Iceboot and try softboot
    resetComstats($card, $pair, $dom);
    if($domStatus ne "BAD") {
	logmsg "$card$pair$dom Iceboot/softboot tests...\n" if $interactive;

	# First time through, configboot->iceboot...
	my $cmd = "se.pl $card$pair$dom r .+\\\> 2>&1";
	my $result = `$cmd`;
	if($result !~ /(Iceboot.*?\.\.\.).*?SUCCESS/s) {
	    print DL "\nCard $card pair $pair DOM $dom: Didn't get Iceboot prompt:\n"
		.    "$result\n";
	    print DL comstat($card,$pair,$dom);
	    print DL fpga($card);
	    $domStatus = "BAD";
	} else {       
	    my $domtag = $1; chomp $domtag;
	    print DL "DOM IceBoot Release Tag: '$1'\n";

	    # Subsequent trials - softboot and collect Iceboot prompts
	    foreach my $trial (0..$numIceBootSoftBootTests-1) {
		  # Try softboot
		my $cmd = "sb.pl $card$pair$dom 2>&1";
		my $result = `$cmd`;
		if($result !~ /Ok./) {
		    print DL "\nCard $card pair $pair DOM $dom: Softboot failed:\n"
			.    "$result\n";
		    print DL comstat($card,$pair,$dom);
		    print DL fpga($card);
		    $domStatus = "BAD";
		    last;
		}
		sleep 4;
		
		$cmd = "se.pl $card$pair$dom \\  .+\\\> 2>&1";
		$result = `$cmd`;
		if($result !~ /(Iceboot.*?\.\.\.).*?SUCCESS/s) {
		    print DL "\nCard $card pair $pair DOM $dom: Didn't get Iceboot prompt:\n"
			.    "$result\n";
		    print DL comstat($card,$pair,$dom);
		    print DL fpga($card);
		    $domStatus = "BAD";
		    last;
		}
	    }
	}
    }

    # After iceboot/softboot tests, check hardware timeouts, IC/CI, RESENT and BADSEQ

    if($domStatus ne "BAD") {
	showstats ("iceboot/softboot test", $maxICCIs * $numIceBootSoftBootTests);
    }

    # Perform cyclic echo tests for each DOM...
    # configboot has to come last because it doesn't support softboot.
    foreach my $sbi ("iceboot.sbi", "domapp.sbi", "configboot.sbi") {
	if($domStatus ne "BAD") {
	    # Prepare state by softbooting...
	    my $cmd = "sb.pl $card$pair$dom 2>&1";
	    my $result = `$cmd`;
	    if($result !~ /Ok./) {
		print DL "\nCard $card pair $pair DOM $dom: Softboot failed:\n"
		    .    "$result\n";
		print DL comstat($card,$pair,$dom);
		print DL fpga($card);
		$domStatus = "BAD";
		last;
	    }
	    sleep 4;

	    # ... and loading the correct FPGA...
	    $cmd = "se.pl $card$pair$dom "
		.  "s\\\"\\\ $sbi\\\"\\\ find\\\ if\\\ fpga\\\ endif s\\\".+\\\> 2>&1";
	    $result = `$cmd`;
	    if($result !~ /SUCCESS/) {
		print DL "\nCard $card pair $pair DOM $dom: FPGA load failed:\n"
		    .    "$result\n";
		print DL comstat($card,$pair,$dom);
		print DL fpga($card);
		$domStatus = "BAD";
		last;
	    }

	    # ... and firing up echo-mode...

            $cmd = "se.pl $card$pair$dom echo-mode echo-mode";
	    $result = `$cmd`;
            if($result !~ /SUCCESS/) {
                print DL "\nCard $card pair $pair DOM $dom: echo-mode failed:\n"
                    .    "$result\n";
                print DL comstat($card,$pair,$dom);
                print DL fpga($card);
                $domStatus = "BAD";
                last;
            }

	    # reset comstats here so we focus on echo test behavior
	    
	    resetComstats($card, $pair, $dom);
	    logmsg "$card$pair$dom $sbi echo test ...\n" if $interactive;
	    $cmd = "readwrite HUB $card$pair$dom -s $numEchoMessagesPerFW 2>&1";
	    $result = `$cmd`;
	    if($result !~/SUCCESS/) {
		print DL "\nCard $card pair $pair DOM $dom: Failed echo test:\n"
		    .    "$result\n";
		print DL comstat($card,$pair,$dom);
		print DL fpga($card);
		$domStatus = "BAD";
		last;
	    }
	    
	    showstats("$sbi echotest", $maxICCIs);
	}
    }

    print DL "Sum of IC/CI for all operations: $opensum\n";
    print DL "Sum of lost packets for all operations: $packetloss\n";

    # Note status changes so parent process can collect results
    print DL "DOM status after per-DOM tests is $domStatus\n";
    close DL;
}


sub showDomFailures {
    my @detailedDOMLogs = @_;
    foreach my $dl (@detailedDOMLogs) {
	if(-f $dl) {
	    logmsg <<EOF;
------- Detailed log of non-good DOM $dl -----------
EOF
;
	    open DL, $dl || logdie "Can't open $dl: $!\n";
	    for(<DL>) {
		logmsg $_;
	    }
	    close DL;
	    logmsg "\n\n";
	}
    }
}

sub checkForRunning {
    my @haveEm;
    my @ps = `ps --columns 1000 ax`;
    foreach my $ps(@ps) {
        chomp $ps;
        if($ps =~ m|/usr/local/bin/quadtool| ||
	   $ps =~ m|perl .*?quadtool|) {
	    my $pid = (split ' ', $ps)[0];
	    if($pid != $$) {
                print "Existing process \"$ps\"...\n";
                push @haveEm, $pid;
            }
	}
    }
    if(@haveEm) {
	die  "Quadtool is already running - please wait for it "
	    ."to finish\nor kill it.\n";
    }
}


sub driverPresent { 
    my $lsmod = `lsmod | grep dh`;
    if($lsmod =~ /^dh\s+/) { return 1; }
    return 0;
}


sub driverVersion { 
    my $fvers = `fvers.pl 2>&1`;
    if($fvers =~ /Driver (\S+)/) {
	return $1;
    } else {
	return "UNKNOWN-NO-FVERS.PL";
    }
}


sub plugged { 
    my $card = shift; my $pair = shift; die unless defined $card && defined $pair;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/is-plugged`;
    if($pf =~ /is plugged in/) { return 1; }
    return 0;
}


sub timeString    {
    my ($sec,$min,$hr,$mday,$mon,$yr,$wday,$yday,$isdst) = localtime;
    $yr += 1900;
    $mon++;
    my $ts = sprintf("$yr-%02d-%02d__%02d-%02d-%02d", $mon, $mday, $hr, $min, $sec);
}

sub pairCurrent { 
    my $card = shift; my $pair = shift; 
    die unless defined $card && defined $pair;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/current`;
    if($pf =~ /current is (\d+) mA/) {
	return $1;
    } else {
	return "UNKNOWN!";
    }
}

sub pairVoltage { 
    my $card = shift; my $pair = shift; 
    die unless defined $card && defined $pair;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/voltage`;
    if($pf =~ /voltage is (\S+) Volts/) {
	return $1;
    } else {
	return "UNKNOWN!";
    }
}


sub pairIsPowered { 
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/pwr`;
# Card 0 Pair 0 power status is off.
    if($pf =~ /status is (\w+)/) {
	if($1 eq "off") {
	    return 0;
	} elsif($1 eq "on") {
	    return 1;
	}
    }
    die "Bad proc file format: $pf";
}

sub resetPowerLimitChecks {

    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $pf = "/proc/driver/domhub/card$card/pair$pair/pwr_check";
    open (PF, ">$pf") || die "Can't open $pf: $!\n";
    print PF "reset";
    close PF;
}


sub dorRev {
    my $card = shift; die unless defined $card;
    my $pf = `cat /proc/driver/domhub/card$card/rev`;
    chomp $pf;
    return $pf;
}

sub onCurrentVoltageWithinLimits {
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/pwr_check`;
# Card 0 pair 0 pwr check: plugged(ok) current(ok,ok) voltage(ok,ok)
    if($pf =~ /pwr check: plugged\(ok\) current\(ok,ok\) voltage\(ok,ok\)/) {
	return 1;
    } else {
	return 0;
    }
}

sub nRXIC {
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    my $comstat = comstat($card,$pair,$dom);
    if($comstat =~ /RX:.*?NIC=(\d+)/s) {
	return $1;
    } else {
	logdie "ERROR: bad comstat format, $comstat\n";
    }
}

sub nTXIC {
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    my $comstat = comstat($card,$pair,$dom);
    if($comstat =~ /TX:.*?NIC=(\d+)/s) {
        return $1;
    } else {
        logdie "ERROR: bad comstat format, $comstat\n";
    }

}

sub nRXCI {
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    my $comstat = comstat($card,$pair,$dom);
    if($comstat =~ /RX:.*?NCI=(\d+)/s) {
        return $1;
    } else {
        logdie "ERROR: bad comstat format, $comstat\n";
    }
}

sub nTXCI {
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    my $comstat = comstat($card,$pair,$dom);
    if($comstat =~ /TX:.*?NCI=(\d+)/s) {
        return $1;
    } else {
        logdie "ERROR: bad comstat format, $comstat\n";
    }
}

sub nRESENT {
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    my $comstat = comstat($card,$pair,$dom);
    if($comstat =~ /RESENT=(\d+)/) {
	return $1;
    }else {
        logdie "ERROR: bad comstat format, $comstat\n";
    }
}

sub nBADSEQ {
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    my $comstat = comstat($card,$pair,$dom);
    if($comstat =~ /BADSEQ=(\d+)/) {
        return $1;
    }else {
        logdie "ERROR: bad comstat format, $comstat\n";
    }
}

sub hadHardwareTimeout {
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $dom  = shift; die unless defined $dom;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/dom$dom/comstat`;
    if($pf =~ /NHDWRTIMEOUTS=(\d+)/) {
	return ($1 ? 1 : 0);
    } else {
	die "Bad proc file format for comstat: $pf\n";
    }
}


sub comstat {
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $dom  = shift; die unless defined $dom;
    return "Comstat proc file for $card$pair$dom:\n"
	.  `cat /proc/driver/domhub/card$card/pair$pair/dom$dom/comstat`;
}


sub fpga {
    my $card = shift; die unless defined $card;
    return "FPGA register dump for card $card:\n"
	.  `cat /proc/driver/domhub/card$card/fpga`;
}


sub resetComstats { 
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $dom  = shift; die unless defined $dom;
    open (PF, ">/proc/driver/domhub/card$card/pair$pair/dom$dom/comstat")
	|| die "Can't open comstat proc file!\n";
    print PF "reset";
    close PF;
}


sub powerDownPair {
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    open(PF, ">/proc/driver/domhub/card$card/pair$pair/pwr")
        or logdie "Can't open power proc file: $!\n";
    print PF "off\n";
    close PF;
}


sub is_communicating { 
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless ($dom eq "A" || $dom eq "B");
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/dom$dom/is-communicating`;
    return ($pf =~ /is communicating/) ? 1 : 0;
}

sub powerOnPair {
# Apply power to wire pair and determine which DOMs are communicating
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    my $onargs = "";
    open(PF, ">/proc/driver/domhub/card$card/pair$pair/pwr") 
	or logdie "Can't open power proc file: $!\n";
    print PF "on\n";
    close PF;
    return ("A"=>is_communicating($card, $pair, "A"),
	    "B"=>is_communicating($card, $pair, "B"));
}

sub getPostRunStatus {
    my $logFile = shift; logdie "getPostRunStatus needs an argument!\n" unless defined $logFile;
    if(! -f $logFile) {
	logmsg "\t(DOM log file $logFile not available)\n";
	return "BAD";
    }
    my $now = time;
    my $tail;
    $tail = `tail $logFile`;
    if($tail =~ /DOM status after per-DOM tests is (\S+)/) {
	return $1;
    } else {
	logmsg "$logFile corrupt:\n$tail\n";
    }
    return "BAD";
}


sub reapKids {
    use POSIX ":sys_wait_h";
    my $kid;
    while(1) {
        $kid = waitpid(-1, &WNOHANG);
        if($kid == -1) {
            last;
        } else {
            select(undef,undef,undef,0.01);
        }
    }
}
