#!/usr/bin/perl

# quadtool
# John Jacobsen, NPX Designs, Inc., jacobsen@npxdesigns.com
# Started: Fri Jul  1 13:40:54 2005

package QUADTOOL;

sub usage { return <<EOU;
Usage: quadtool <card> 01 or <card> 23
          01: first quad (wire pairs 0, 1)
	  23: second quad (wire pairs 2, 3)
Options:
	  -t : Log results to terminal; don't background

EOU
;
}


use Fcntl;
use strict;

my $numOpenTests = 10;

use Getopt::Long;
my $interactive;
my $help;
GetOptions("help|h"          => \$help,
	   "t"               => \$interactive) || die usage;
die usage if $help;

sub checkForRunning;
sub driverPresent;
sub driverVersion;
sub moatVersion { my $mv = `cat /usr/local/share/moat-version`; chomp $mv; return $mv; }
sub hostName { my $h = `hostname 2>&1`; chomp $h; return $h; }
sub plugged;
sub timeString;
sub pairCurrent;
sub pairVoltage;
sub currentIsSmall { my $cur = shift; return $cur < 5 ? 1 : 0; }
sub pairIsPowered;
sub resetPowerLimitChecks;
sub onCurrentVoltageWithinLimits;
sub hadHardwareTimeout;
sub resetComstats;
sub doDom;
sub powerDownPair;
sub is_communicating;
sub powerOnQuad;
sub getPostRunStatus;
sub reapKids;
sub comstat;
sub fpga;

print "Welcome to $0, by jacobsen\@npxdesigns.com.\n";
checkForRunning;

my $card = shift; 
die usage unless defined $card && $card =~ /^\d+$/ && $card >= 0 && $card <= 7;

my $pairPair = shift;
die usage unless $pairPair eq "01" || $pairPair eq "23";
my @pairs;
if($pairPair eq "01") { @pairs = (0, 1); }
if($pairPair eq "23") { @pairs = (2, 3); }

my $now = timeString;
my $testdir = "QUADTOOL__card$card"."_pair$pairPair"."_$now";
my $logfile = "QUADTOOL.out";

print "Creating $testdir... ";
mkdir $testdir or die "Can't create $testdir: $!\n";
print "OK.\n";
print "Creating symlink latest_quadtool to $testdir... ";
if(-e "latest_quadtool") {
    unlink "latest_quadtool" or die "Can't unlink existing latest_quadtool: $!\n";
}
symlink($testdir, "latest_quadtool")
    or die "Can't symlink $testdir"."->latest_quadtool: $!.\n";
print "OK.\n";

chdir $testdir || die "Can't chdir $testdir: $!\n";

exit if ! $interactive && fork;

open LOG, ">$logfile" || die "Can't open $logfile: $!\n";
my $ofh = select(LOG); $| = 1; select $ofh;

sub logmsg { my $m = shift; print LOG $m; if($interactive) { print $m; } }
sub logdie { my $m = shift; print LOG $m; if($interactive) { die $m; } else { exit(-1); } }

logdie "No DOR driver present!\n" unless driverPresent;
logmsg "\n---------------------------------------------------\nCONFIGURATION:\n";
logmsg "   Test start time: $now\n";
logmsg "DOR driver version: ".driverVersion."\n";
logmsg "      MOAT version: ".moatVersion."\n";
logmsg "          Hostname: ".hostName."\n";
logmsg "          DOR card: $card\n";
logmsg "        Wire pairs: ".(join ' ', @pairs)."\n";
my %pairstat;
my %domstat;

foreach my $pair (@pairs) {
    $pairstat{$pair} = "OK";
    foreach my $dom ("A","B") {
        $domstat{$pair}{$dom} = "OK";
    }
}

sub failPair { 
    my $pair = shift; logdie unless defined $pair;
    $pairstat{$pair} = "BAD"; 
    $domstat{$pair}{"A"} = "BAD";
    $domstat{$pair}{"B"} = "BAD";
}

sub failDom {
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    $domstat{$pair}{$dom} = "BAD";
}

sub iffyDom {
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    $domstat{$pair}{$dom} = "POOR";
}

logmsg "\n---------------------------------------------------\nTEST DETAILS:\n";

foreach my $pair (@pairs) {
    $pairstat{$pair} = "OK";
    if(!plugged($card, $pair)) {
	logmsg "Pair $pair is NOT plugged in.\n";
	failPair($pair);
	next;
    } else {
	logmsg "Pair $pair is plugged in.\n";
    }
    if(pairIsPowered($card, $pair)) {
	logmsg "Pail $pair is already powered on!  "
	    .  "Please make sure nobody\n is using the "
	    .  "DOMs, and \"off all\" first....\n";
	exit;
    }
    my $current = pairCurrent($card,$pair);
    logmsg "Pair $pair current (power off): $current mA: ";
    if(!currentIsSmall($current)) {
	logmsg "current with power off is too large!\n";
	failPair($pair);
	next;
    } else {
	logmsg "OK.\n";
    }

    resetComstats($card, $pair, "A");
    resetComstats($card, $pair, "B");
    resetPowerLimitChecks($card, $pair);
}

my %isCom = powerOnQuad($card, @pairs);

foreach my $pair (@pairs) {
    if($pairstat{$pair} ne "BAD") {
	$current  = pairCurrent($card, $pair);
	my $voltage  = pairVoltage($card, $pair);
	logmsg "Pair $pair current=$current mA, voltage=$voltage V\n";
	# Check current, voltage
	if(!onCurrentVoltageWithinLimits($card, $pair)) {
	    logmsg "Current or voltage is not in limits!\n"
		.  `cat /proc/driver/domhub/card$card/pair$pair/pwr_check`;
	    failPair($pair);
	    next;
	}
	foreach my $dom ("A", "B") {
	    if(! $isCom{$dom}) {
		logmsg "Pair $pair DOM $dom is NOT communicating after power on.\n";
		failDom($pair,$dom);
		next;
	    } 
	    logmsg "Pair $pair DOM $dom is communicating after power on.\n";
	}
	# Next step - check again, look for hardware timeouts
	sleep 1;
	foreach my $dom ("A", "B") {
	    if(! is_communicating($card, $pair, $dom)) {
		logmsg "Pair $pair DOM $dom did not communicate a short while after power on.\n";
		failDom($pair, $dom);
		next;
	    }
	    logmsg "Pair $pair DOM $dom is-communicating again after power on.\n";
	    if(hadHardwareTimeout($card, $pair, $dom)) {
		logmsg "DOM $dom had a hardware timeout!\n";
		failDom($pair, $dom);
		next;
	    }
	    logmsg "DOM $dom did not have a hardware timeout.\n";
	}
    }
}

foreach my $pair (@pairs) {
    # Perform parallel comms test for each DOM.
    if($pairstat{$pair} ne "BAD") {
	foreach my $dom ("A", "B") { 
	    if($domstat{$pair}{$dom} ne "BAD") {
		my $domLog = "$pair$dom.log"; 
		logmsg "Launching comms quality tests on $pair$dom, will save "
		    .  "results to $domLog... \n";
		my $pid = fork;
		if(!defined $pid) {
		    logmsg "Fork failed on $pair $dom!\n";
		    next;
		}
		if($pid == 0) { # Kid does stuff
		    doDom($card, $pair, $dom, $domLog);
		    exit;
		}
	    }
	}
    }
}

reapKids;

logmsg "\n---------------------------------------------------\nPASS/FAIL:\n";
foreach my $pair (@pairs) {
    logmsg "Card $card pair $pair: ";
    my $stat = $pairstat{$pair}; 
    if($stat eq "BAD") {
	logmsg "BAD\n"; 
    } else {
	logmsg "\n";
	foreach my $dom ("A","B") {
	    my $domStatus = getPostRunStatus("$pair$dom.log");
	    logmsg "        DOM $dom: $domStatus\n";
	}
    }
    powerDownPair($card, $pair);
}
logmsg "Done.\n";
close LOG;
exit;

sub doDom {
    my $card = shift; logdie unless defined $card;
    my $pair = shift; logdie unless defined $pair;
    my $dom  = shift; logdie unless defined $dom;
    logdie unless ($dom eq "A" || $dom eq "B");
    my $log  = shift; logdie unless defined $log;
    open (DL, ">$log") or logdie "Can't open $log: $!\n";
    my $domStatus = $domstat{$pair}{$dom};
    print DL "Starting comms. tests on $card$pair$dom...\n";

    foreach my $trial (0..$numOpenTests-1) {
	print `cat /proc/driver/domhub/card$card/pair$pair/pwr`;
	print `cat /proc/driver/domhub/card$card/pair$pair/dom$dom/is-communicating`;
	print `cat /proc/driver/domhub/card$card/pair$pair/dom$dom/comstat`;
	my $openresult = `/usr/local/bin/singleopen $card$pair$dom 2>&1`;
	chomp $openresult;
	if($openresult =~ /^OK\./) {
	    print DL "Open $trial succeeded.\n";
	} else {
	    print `cat /proc/driver/domhub/card$card/pair$pair/dom$dom/comstat`;
	    print `cat /proc/driver/domhub/card$card/fpga`;
	    print DL "Open $trial FAILED ($openresult)\n";
	    print DL comstat($card,$pair,$dom);
	    print DL fpga($card);
	    $domStatus = "BAD";
	    last;
	}
    }

    # Note status changes so parent process can collect results
    print DL "DOM status after per-DOM tests is $domStatus\n";
    close DL;
}

sub checkForRunning {
    my @haveEm;
    my @ps = `ps --columns 1000 ax`;
    foreach my $ps(@ps) {
        chomp $ps;
        if($ps =~ m|/usr/local/bin/quadtool| ||
	   $ps =~ m|perl .*?quadtool|) {
	    my $pid = (split ' ', $ps)[0];
	    if($pid != $$) {
                print "Existing process \"$ps\"...\n";
                push @haveEm, $pid;
            }
	}
    }
    if(@haveEm) {
	die  "Quadtool is already running - please wait for it "
	    ."to finish\nor kill it.\n";
    }
}


sub driverPresent { 
    my $lsmod = `lsmod | grep dh`;
    if($lsmod =~ /^dh\s+/) { return 1; }
    return 0;
}


sub driverVersion { 
    my $fvers = `fvers.pl 2>&1`;
    if($fvers =~ /Driver (\S+)/) {
	return $1;
    } else {
	return "UNKNOWN-NO-FVERS.PL";
    }
}


sub plugged { 
    my $card = shift; my $pair = shift; die unless defined $card && defined $pair;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/is-plugged`;
    if($pf =~ /is plugged in/) { return 1; }
    return 0;
}


sub timeString    {
    my ($sec,$min,$hr,$mday,$mon,$yr,$wday,$yday,$isdst) = localtime;
    $yr += 1900;
    $mon++;
    my $ts = sprintf("$yr-%02d-%02d__%02d-%02d-%02d", $mon, $mday, $hr, $min, $sec);
}

sub pairCurrent { 
    my $card = shift; my $pair = shift; 
    die unless defined $card && defined $pair;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/current`;
    if($pf =~ /current is (\d+) mA/) {
	return $1;
    } else {
	return "UNKNOWN!";
    }
}

sub pairVoltage { 
    my $card = shift; my $pair = shift; 
    die unless defined $card && defined $pair;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/voltage`;
    if($pf =~ /voltage is (\S+) Volts/) {
	return $1;
    } else {
	return "UNKNOWN!";
    }
}


sub pairIsPowered { 
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/pwr`;
# Card 0 Pair 0 power status is off.
    if($pf =~ /status is (\w+)/) {
	if($1 eq "off") {
	    return 0;
	} elsif($1 eq "on") {
	    return 1;
	}
    }
    die "Bad proc file format: $pf";
}

sub resetPowerLimitChecks {

    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $pf = "/proc/driver/domhub/card$card/pair$pair/pwr_check";
    open (PF, ">$pf") || die "Can't open $pf: $!\n";
    print PF "reset";
    close PF;
}


sub onCurrentVoltageWithinLimits {
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/pwr_check`;
# Card 0 pair 0 pwr check: plugged(ok) current(ok,ok) voltage(ok,ok)
    if($pf =~ /pwr check: plugged\(ok\) current\(ok,ok\) voltage\(ok,ok\)/) {
	return 1;
    } else {
	return 0;
    }
}


sub hadHardwareTimeout {
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $dom  = shift; die unless defined $dom;
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/dom$dom/comstat`;
    if($pf =~ /NHDWRTIMEOUTS=(\d+)/) {
	return ($1 ? 1 : 0);
    } else {
	die "Bad proc file format for comstat: $pf\n";
    }
}


sub comstat {
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $dom  = shift; die unless defined $dom;
    return "Comstat proc file for $card$pair$dom:\n"
	.  `cat /proc/driver/domhub/card$card/pair$pair/dom$dom/comstat`;
}


sub fpga {
    my $card = shift; die unless defined $card;
    return "FPGA register dump for card $card:\n"
	.  `cat /proc/driver/domhub/card$card/fpga`;
}


sub resetComstats { 
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $dom  = shift; die unless defined $dom;
    open (PF, ">/proc/driver/domhub/card$card/pair$pair/dom$dom/comstat")
	|| die "Can't open comstat proc file!\n";
    print PF "reset";
    close PF;
}


sub powerDownPair {
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    open(PF, ">/proc/driver/domhub/card$card/pair$pair/pwr")
        or die "Can't open power proc file: $!\n";
    print PF "off\n";
    close PF;
}


sub is_communicating { 
    my $card = shift; die unless defined $card;
    my $pair = shift; die unless defined $pair;
    my $dom  = shift; die unless ($dom eq "A" || $dom eq "B");
    my $pf = `cat /proc/driver/domhub/card$card/pair$pair/dom$dom/is-communicating`;
    return ($pf =~ /is communicating/) ? 1 : 0;
}

sub powerOnQuad {
# Apply power to wire pair and determine which DOMs are communicating
    my $card = shift; die unless defined $card;
    my $onargs = "";
    foreach my $pair (@_) {
	my 
    my $pair = shift; die unless defined $pair;
    open(PF, ">/proc/driver/domhub/card$card/pair$pair/pwr") 
	or die "Can't open power proc file: $!\n";
    print PF "on\n";
    close PF;
    return ("A"=>is_communicating($card, $pair, "A"),
	    "B"=>is_communicating($card, $pair, "B"));
}

sub getPostRunStatus {
    my $logFile = shift; logdie "getPostRunStatus needs an argument!\n" unless defined $logFile;
    if(! -f $logFile) {
	logmsg "Can't find DOM log file $logFile!\n";
	return "BAD";
    }
    my $now = time;
    my $tail;
    $tail = `tail $logFile`;
    if($tail =~ /DOM status after per-DOM tests is (\S+)/) {
	return $1;
    } else {
	logmsg "$logFile corrupt:\n$tail\n";
    }
    return "BAD";
}


sub reapKids {
    use POSIX ":sys_wait_h";
    my $kid;
    while(1) {
        $kid = waitpid(-1, &WNOHANG);
        if($kid == -1) {
            last;
        } else {
            select(undef,undef,undef,0.01);
        }
    }
}
